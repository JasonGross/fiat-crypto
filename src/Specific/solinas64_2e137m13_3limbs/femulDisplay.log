mul = λ var : Z.Syntax.base_type → Type,
λ '(x4, x5, x3, (x8, x9, x7))%core,
uint128_t x10 = (0x2 * ((uint128_t)x4 * x8));
uint128_t x11 = ((0x2 * ((uint128_t)x5 * x8)) + (0x2 * ((uint128_t)x4 * x9)));
uint128_t x12 = (((uint128_t)x3 * x8) + (((uint128_t)x5 * x9) + ((uint128_t)x4 * x7)));
uint128_t x13 = (((uint128_t)x3 * x9) + ((uint128_t)x5 * x7));
uint128_t x14 = ((uint128_t)x3 * x7);
uint128_t x15 = (x13 + (0xd * x10));
uint128_t x16 = (x14 + (0xd * x11));
uint64_t x17 = (uint64_t) (x16 >> 0x2e);
uint64_t x18 = ((uint64_t)x16 & 0x3fffffffffff);
uint128_t x19 = (x17 + x15);
uint64_t x20 = (uint64_t) (x19 >> 0x2e);
uint64_t x21 = ((uint64_t)x19 & 0x3fffffffffff);
uint128_t x22 = (x20 + x12);
uint64_t x23 = (uint64_t) (x22 >> 0x2d);
uint64_t x24 = ((uint64_t)x22 & 0x1fffffffffff);
uint64_t x25 = (x18 + (0xd * x23));
uint64_t x26 = (x25 >> 0x2e);
uint64_t x27 = (x25 & 0x3fffffffffff);
uint64_t x28 = (x26 + x21);
uint64_t x29 = (x28 >> 0x2e);
uint64_t x30 = (x28 & 0x3fffffffffff);
return ((x29 + x24), Return x30, Return x27)
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint64_t * uint64_t * uint64_t * (uint64_t * uint64_t * uint64_t) -> uint64_t * uint64_t * uint64_t)

Argument scope is [function_scope]

add = λ var : Z.Syntax.base_type → Type,
λ '(x4, x5, x3, (x8, x9, x7))%core,
uint64_t x11, uint8_t x12 = addcarryx_u64(0x0, x3, x7);
uint64_t x14, uint8_t x15 = addcarryx_u64(x12, x5, x9);
uint64_t x17, uint8_t x18 = addcarryx_u64(x15, x4, x8);
uint64_t x20, uint8_t x21 = subborrow_u64(0x0, x11, 0xfffffffffffffffdL);
uint64_t x23, uint8_t x24 = subborrow_u64(x21, x14, 0xffffffffffffffffL);
uint64_t x26, uint8_t x27 = subborrow_u64(x24, x17, 0x3fffffffffff);
uint64_t _, uint8_t x30 = subborrow_u64(x27, x18, 0x0);
(cmovznz64(x30, x26, x17), cmovznz64(x30, x23, x14), cmovznz64(x30, x20, x11))
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint64_t * uint64_t * uint64_t * (uint64_t * uint64_t * uint64_t) -> uint64_t * uint64_t * uint64_t)

Argument scope is [function_scope]

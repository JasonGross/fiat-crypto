sub = λ var : Z.Syntax.base_type → Type,
λ '(x14, x15, x13, x11, x9, x7, x5, x3, (x28, x29, x27, x25, x23, x21, x19, x17))%core,
uint64_t x31, uint8_t x32 = subborrow_u64(0x0, x3, x17);
uint64_t x34, uint8_t x35 = subborrow_u64(x32, x5, x19);
uint64_t x37, uint8_t x38 = subborrow_u64(x35, x7, x21);
uint64_t x40, uint8_t x41 = subborrow_u64(x38, x9, x23);
uint64_t x43, uint8_t x44 = subborrow_u64(x41, x11, x25);
uint64_t x46, uint8_t x47 = subborrow_u64(x44, x13, x27);
uint64_t x49, uint8_t x50 = subborrow_u64(x47, x15, x29);
uint64_t x52, uint8_t x53 = subborrow_u64(x50, x14, x28);
uint64_t x54 = cmovznz64(x53, 0x0, 0xffffffffffffffffL);
uint64_t x56, uint8_t x57 = addcarryx_u64(0x0, x31, (x54 & 0xfffffffffffffe1fL));
uint64_t x59, uint8_t x60 = addcarryx_u64(x57, x34, (x54 & 0xffffffffffffffffL));
uint64_t x62, uint8_t x63 = addcarryx_u64(x60, x37, (x54 & 0xffffffffffffffffL));
uint64_t x65, uint8_t x66 = addcarryx_u64(x63, x40, (x54 & 0xffffffffffffffffL));
uint64_t x68, uint8_t x69 = addcarryx_u64(x66, x43, (x54 & 0xffffffffffffffffL));
uint64_t x71, uint8_t x72 = addcarryx_u64(x69, x46, (x54 & 0xffffffffffffffffL));
uint64_t x74, uint8_t x75 = addcarryx_u64(x72, x49, (x54 & 0xffffffffffffffffL));
uint64_t x77, uint8_t _ = addcarryx_u64(x75, x52, (x54 & 0x7fffffffffffffffL));
(Return x77, Return x74, Return x71, Return x68, Return x65, Return x62, Return x59, Return x56)
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * (uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t) -> uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t * uint64_t)

Argument scope is [function_scope]

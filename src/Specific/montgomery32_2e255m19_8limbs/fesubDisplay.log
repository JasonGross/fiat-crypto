sub = λ var : Z.Syntax.base_type → Type,
λ '(x14, x15, x13, x11, x9, x7, x5, x3, (x28, x29, x27, x25, x23, x21, x19, x17))%core,
uint32_t x31, uint8_t x32 = subborrow_u32(0x0, x3, x17);
uint32_t x34, uint8_t x35 = subborrow_u32(x32, x5, x19);
uint32_t x37, uint8_t x38 = subborrow_u32(x35, x7, x21);
uint32_t x40, uint8_t x41 = subborrow_u32(x38, x9, x23);
uint32_t x43, uint8_t x44 = subborrow_u32(x41, x11, x25);
uint32_t x46, uint8_t x47 = subborrow_u32(x44, x13, x27);
uint32_t x49, uint8_t x50 = subborrow_u32(x47, x15, x29);
uint32_t x52, uint8_t x53 = subborrow_u32(x50, x14, x28);
uint32_t x54 = cmovznz32(x53, 0x0, 0xffffffff);
uint32_t x56, uint8_t x57 = addcarryx_u32(0x0, x31, (x54 & 0xffffffed));
uint32_t x59, uint8_t x60 = addcarryx_u32(x57, x34, (x54 & 0xffffffff));
uint32_t x62, uint8_t x63 = addcarryx_u32(x60, x37, (x54 & 0xffffffff));
uint32_t x65, uint8_t x66 = addcarryx_u32(x63, x40, (x54 & 0xffffffff));
uint32_t x68, uint8_t x69 = addcarryx_u32(x66, x43, (x54 & 0xffffffff));
uint32_t x71, uint8_t x72 = addcarryx_u32(x69, x46, (x54 & 0xffffffff));
uint32_t x74, uint8_t x75 = addcarryx_u32(x72, x49, (x54 & 0xffffffff));
uint32_t x77, uint8_t _ = addcarryx_u32(x75, x52, (x54 & 0x7fffffff));
(Return x77, Return x74, Return x71, Return x68, Return x65, Return x62, Return x59, Return x56)
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t) -> uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t)

Argument scope is [function_scope]

(* This file is autogenerated from Base.v by remake_packages.py *)
Require Export Crypto.Specific.Framework.ArithmeticSynthesis.Base.

Ltac get_ArithmeticSynthesisBase_package CurveParameters_pkg :=
  lazymatch (eval hnf in CurveParameters_pkg) with
  | (?sz, ?bitwidth, ?s, ?c, ?carry_chains, ?a24, ?coef_div_modulus, ?goldilocks, ?montgomery, ?modinv_fuel)
    => let r := fresh "r" in
       let m := fresh "m" in
       let m' := fresh "m'" in
       let r' := fresh "r'" in
       let m'_correct := fresh "m'_correct" in
       let r'_correct := fresh "r'_correct" in
       let wt := fresh "wt" in
       let sz2 := fresh "sz2" in
       let half_sz := fresh "half_sz" in
       let half_sz_nonzero := fresh "half_sz_nonzero" in
       let m_enc := fresh "m_enc" in
       let coef := fresh "coef" in
       let coef_mod := fresh "coef_mod" in
       let sz_nonzero := fresh "sz_nonzero" in
       let wt_nonzero := fresh "wt_nonzero" in
       let wt_nonneg := fresh "wt_nonneg" in
       let wt_divides := fresh "wt_divides" in
       let wt_divides' := fresh "wt_divides'" in
       let wt_divides_chains := fresh "wt_divides_chains" in
       let wt_pos := fresh "wt_pos" in
       let wt_multiples := fresh "wt_multiples" in
       let r := pose_r bitwidth r in
       let m := pose_m s c m in
       let m' := pose_m' modinv_fuel m r m' in
       let r' := pose_r' modinv_fuel m r r' in
       let m'_correct := pose_m'_correct m m' r m'_correct in
       let r'_correct := pose_r'_correct m r r' r'_correct in
       let wt := pose_wt m sz wt in
       let sz2 := pose_sz2 sz sz2 in
       let half_sz := pose_half_sz sz half_sz in
       let half_sz_nonzero := pose_half_sz_nonzero half_sz half_sz_nonzero in
       let m_enc := pose_m_enc sz s c wt m_enc in
       let coef := pose_coef sz wt m_enc coef_div_modulus coef in
       let coef_mod := pose_coef_mod sz wt m coef coef_mod in
       let sz_nonzero := pose_sz_nonzero sz sz_nonzero in
       let wt_nonzero := pose_wt_nonzero wt wt_nonzero in
       let wt_nonneg := pose_wt_nonneg wt wt_nonneg in
       let wt_divides := pose_wt_divides wt wt_divides in
       let wt_divides' := pose_wt_divides' wt wt_divides wt_divides' in
       let wt_divides_chains := pose_wt_divides_chains wt carry_chains wt_divides' wt_divides_chains in
       let wt_pos := pose_wt_pos wt wt_pos in
       let wt_multiples := pose_wt_multiples wt wt_multiples in
       constr:((r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples))
  end.

Ltac make_ArithmeticSynthesisBase_package CurveParameters_pkg :=
  lazymatch goal with
  | [ |- { T : _ & T } ] => eexists
  | [ |- _ ] => idtac
  end;
  let pkg := get_ArithmeticSynthesisBase_package CurveParameters_pkg in
  exact pkg.

Module Type ArithmeticSynthesisBasePrePackage.
  Parameter ArithmeticSynthesisBase_package' : { T : _ & T }.
  Parameter ArithmeticSynthesisBase_package : projT1 ArithmeticSynthesisBase_package'.
End ArithmeticSynthesisBasePrePackage.

Module MakeArithmeticSynthesisBaseTest (PKG : ArithmeticSynthesisBasePrePackage).
  Ltac get_MakeArithmeticSynthesisBaseTest_package _ := eval hnf in PKG.ArithmeticSynthesisBase_package.
  Ltac Base_reduce_proj x :=
    eval cbv beta iota zeta in x.

  Ltac get_r _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in r).
  Notation r := (ltac:(let v := get_r () in exact v)) (only parsing).
  Ltac get_m _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in m).
  Notation m := (ltac:(let v := get_m () in exact v)) (only parsing).
  Ltac get_m' _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in m').
  Notation m' := (ltac:(let v := get_m' () in exact v)) (only parsing).
  Ltac get_r' _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in r').
  Notation r' := (ltac:(let v := get_r' () in exact v)) (only parsing).
  Ltac get_m'_correct _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in m'_correct).
  Notation m'_correct := (ltac:(let v := get_m'_correct () in exact v)) (only parsing).
  Ltac get_r'_correct _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in r'_correct).
  Notation r'_correct := (ltac:(let v := get_r'_correct () in exact v)) (only parsing).
  Ltac get_wt _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt).
  Notation wt := (ltac:(let v := get_wt () in exact v)) (only parsing).
  Ltac get_sz2 _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in sz2).
  Notation sz2 := (ltac:(let v := get_sz2 () in exact v)) (only parsing).
  Ltac get_half_sz _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in half_sz).
  Notation half_sz := (ltac:(let v := get_half_sz () in exact v)) (only parsing).
  Ltac get_half_sz_nonzero _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in half_sz_nonzero).
  Notation half_sz_nonzero := (ltac:(let v := get_half_sz_nonzero () in exact v)) (only parsing).
  Ltac get_m_enc _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in m_enc).
  Notation m_enc := (ltac:(let v := get_m_enc () in exact v)) (only parsing).
  Ltac get_coef _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in coef).
  Notation coef := (ltac:(let v := get_coef () in exact v)) (only parsing).
  Ltac get_coef_mod _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in coef_mod).
  Notation coef_mod := (ltac:(let v := get_coef_mod () in exact v)) (only parsing).
  Ltac get_sz_nonzero _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in sz_nonzero).
  Notation sz_nonzero := (ltac:(let v := get_sz_nonzero () in exact v)) (only parsing).
  Ltac get_wt_nonzero _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_nonzero).
  Notation wt_nonzero := (ltac:(let v := get_wt_nonzero () in exact v)) (only parsing).
  Ltac get_wt_nonneg _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_nonneg).
  Notation wt_nonneg := (ltac:(let v := get_wt_nonneg () in exact v)) (only parsing).
  Ltac get_wt_divides _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_divides).
  Notation wt_divides := (ltac:(let v := get_wt_divides () in exact v)) (only parsing).
  Ltac get_wt_divides' _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_divides').
  Notation wt_divides' := (ltac:(let v := get_wt_divides' () in exact v)) (only parsing).
  Ltac get_wt_divides_chains _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_divides_chains).
  Notation wt_divides_chains := (ltac:(let v := get_wt_divides_chains () in exact v)) (only parsing).
  Ltac get_wt_pos _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_pos).
  Notation wt_pos := (ltac:(let v := get_wt_pos () in exact v)) (only parsing).
  Ltac get_wt_multiples _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in Base_reduce_proj (let '(r, m, m', r', m'_correct, r'_correct, wt, sz2, half_sz, half_sz_nonzero, m_enc, coef, coef_mod, sz_nonzero, wt_nonzero, wt_nonneg, wt_divides, wt_divides', wt_divides_chains, wt_pos, wt_multiples) := pkg in wt_multiples).
  Notation wt_multiples := (ltac:(let v := get_wt_multiples () in exact v)) (only parsing).
End MakeArithmeticSynthesisBaseTest.

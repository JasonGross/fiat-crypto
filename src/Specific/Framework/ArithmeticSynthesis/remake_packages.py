#!/usr/bin/env python
from __future__ import with_statement
import re, os
import io

PACKAGE_NAMES = ['../CurveParameters.v']
PACKAGE_CP_NAMES = ['Base.v']
WITH_CURVE_BASE_NAMES = ['Freeze.v', 'Karatsuba.v', 'Defaults.v', 'Ladderstep.v']
ALL_FILE_NAMES = PACKAGE_NAMES + PACKAGE_CP_NAMES + WITH_CURVE_BASE_NAMES + ['../ReificationTypes.v']
CONFIGS = ('goldilocks', 'montgomery')
           
contents = {}
for fname in ALL_FILE_NAMES:
    with open(fname, 'r') as f:
        contents[fname] = f.read()

lines = dict((k, v.split('\n')) for k, v in contents.items())

EXCLUDES = ('constr:((wt_divides_chain, wt_divides_chains))', )

fns = {}
header = 'Ltac pose_'
for fname in ALL_FILE_NAMES:
    stripped_lines = [i.strip() for i in lines[fname]]
    fns[fname] = [(name, args.strip())
                  for line in stripped_lines
                  if line.startswith(header)
                  for name, args in re.findall('Ltac pose_([^ ]*' + ') ([A-Za-z0-9_\' ]*' + ')', line.strip())]

def get_file_root(folder=os.path.dirname(__file__), filename='Makefile'):
    dir_path = os.path.realpath(folder)
    while not os.path.isfile(os.path.join(dir_path, filename)) and dir_path != '/':
        dir_path = os.path.realpath(os.path.join(dir_path, '..'))
    if not os.path.isfile(os.path.join(dir_path, filename)):
        print('ERROR: Could not find Makefile in the root of %s' % folder)
        raise Exception
    return dir_path

root = get_file_root()

def modname_of_file_name(fname):
    assert(fname[-2:] == '.v')
    return 'Crypto.' + os.path.normpath(os.path.relpath(os.path.realpath(fname), os.path.join(root, 'src'))).replace(os.sep, '.')[:-2]

PY_FILE_NAME = os.path.basename(__file__)

def make_package(fname, extra_modname_prefix='', prefix=None, add_package=True):
    py_file_name = PY_FILE_NAME
    full_mod = modname_of_file_name(fname)
    modname, ext = os.path.splitext(os.path.basename(fname))
    ret = (r'''(* This file is autogenerated from %(modname)s.v by %(py_file_name)s *)
Require Export %(full_mod)s.
''' % locals())
    if prefix is not None:
        ret += prefix
    if add_package:
        ret += (r'''
Module Type %(extra_modname_prefix)s%(modname)sPrePackage.
  Parameter %(extra_modname_prefix)s%(modname)s_package' : { T : _ & T }.
  Parameter %(extra_modname_prefix)s%(modname)s_package : projT1 %(extra_modname_prefix)s%(modname)s_package'.
End %(extra_modname_prefix)s%(modname)sPrePackage.

Module Make%(extra_modname_prefix)s%(modname)sTest (PKG : %(extra_modname_prefix)s%(modname)sPrePackage).
  Ltac get_Make%(extra_modname_prefix)s%(modname)sTest_package _ := eval hnf in PKG.%(extra_modname_prefix)s%(modname)s_package.
  Ltac %(modname)s_reduce_proj x :=
    eval cbv beta iota zeta in x.
''' % locals())
        terms = ', '.join(name for name, args in fns[fname])
        for name, args in fns[fname]:
            ret += ("\n  Ltac get_%s _ := let pkg := get_Make%s%sTest_package () in %s_reduce_proj (let '(%s) := pkg in %s)." % (name, extra_modname_prefix, modname, modname, terms, name))
            ret += ("\n  Notation %s := (ltac:(let v := get_%s () in exact v)) (only parsing)." % (name, name))
        ret += ('\nEnd Make%(extra_modname_prefix)s%(modname)sTest.\n' % locals())
    return ret

def do_replace(fname, headers, new_contents):
    lines = contents[fname].split('\n')
    ret = []
    for line in lines:
        if any(header in line for header in headers):
            ret.append(new_contents)
            break
        else:
            ret.append(line)
    ret = unicode('\n'.join(ret))
    if ret == contents[fname]: return
    #raw_input((ret, ret == contents[fname]))
    print('Writing %s...' % fname)
    with io.open(fname, 'w', newline='\n') as f:
        f.write(unicode(ret))

def write_package(fname, pkg):
    pkg_name = fname[:-2] + 'Package.v'
    if os.path.isfile(pkg_name):
        with open(pkg_name, 'r') as f:
            existing_pkg = f.read()
        if pkg == existing_pkg: return
    pkg = unicode(pkg)
    #raw_input(pkg)
    print('Writing %s...' % pkg_name)
    with io.open(pkg_name, 'w', newline='\n') as f:
        f.write(pkg)

for fname in PACKAGE_NAMES:
    assert(fname == '../CurveParameters.v')
    modname, ext = os.path.splitext(os.path.basename(fname))
    close_modname = 'Fill' + modname
    full_mod = modname_of_file_name(fname)
    header = '(* Everything below this line autogenerated by %s *)' % PY_FILE_NAME
    tactic = 'Ltac get_%s_package _ :=' % modname
    get_make_val = '  %s\n  %s\n    %s' % (header, tactic, '\n    '.join('let %s := fresh "%s" in' % (name, name) for name, args in fns[fname]))
    get_make_val += ('\n    ' + '\n    '.join('let %s := pose_%s %s in' % (name, name, args) for name, args in fns[fname]))
    get_make_val += ('\n    constr:((%s)).' % ', '.join(name for name, args in fns[fname]))
    get_make_val += (r'''

  Ltac make_%(modname)s_package _ :=
    lazymatch goal with
    | [ |- { T : _ & T } ] => eexists
    | [ |- _ ] => idtac
    end;
    let pkg := get_%(modname)s_package () in
    exact pkg.

  Ltac choose %(modname)s_pkg tac :=
    lazymatch (eval hnf in %(modname)s_pkg) with
''' % locals())
    get_make_val += '    | (%s)\n' % ', '.join('?%s' % name for name, args in fns[fname])
    get_make_val += '      => '
    
    get_make_val += '\n         '.join('let %s := (eval compute in (%s : bool)) in' % (i, i) for i in CONFIGS)
    get_make_val += (r'''
         tac %s
    end.
End %s.
''' % (' '.join(CONFIGS), close_modname))
    pkg = make_package(fname)
    print(fname)
    pkg = unicode(pkg)
    do_replace(fname, (header, tactic), get_make_val)
    write_package(fname, pkg)

for fname in PACKAGE_CP_NAMES:
    modname, ext = os.path.splitext(os.path.basename(fname))
    full_mod = modname_of_file_name(fname)
    full_cp_mod = modname_of_file_name('../CurveParameters.v')
    cp_names = tuple(name for name, args in fns['../CurveParameters.v'])
    #raw_input(cp_names)
    prefix = (r'''
Ltac get_ArithmeticSynthesis%(modname)s_package CurveParameters_pkg :=
  lazymatch (eval hnf in CurveParameters_pkg) with
''' % locals())
    prefix += '  | (%s)\n' % ', '.join('?%s' % i for i in cp_names)
    prefix += ('    => %s'
               % '\n       '.join('let %s := fresh "%s" in' % (name, name) for name, args in fns[fname]))
    prefix += ('\n       ' + '\n       '.join('let %s := pose_%s %s in' % (name, name, args) for name, args in fns[fname]))
    prefix += ('\n       constr:((%s))' % ', '.join(name for name, args in fns[fname]))
    prefix += ('\n  end.\n')
    prefix += (r'''
Ltac make_ArithmeticSynthesis%(modname)s_package CurveParameters_pkg :=
  lazymatch goal with
  | [ |- { T : _ & T } ] => eexists
  | [ |- _ ] => idtac
  end;
  let pkg := get_ArithmeticSynthesis%(modname)s_package CurveParameters_pkg in
  exact pkg.
''' % locals())
    pkg = make_package(fname, extra_modname_prefix='ArithmeticSynthesis', prefix=prefix)
    print(fname)
    pkg = unicode(pkg)
    write_package(fname, pkg)

    
full_cp_mod = modname_of_file_name('../CurveParameters.v')
full_base_mod = modname_of_file_name('Base.v')
cp_names = tuple(name for name, args in fns['../CurveParameters.v'])
base_names = tuple(name for name, args in fns['Base.v'])

for fname in WITH_CURVE_BASE_NAMES:
    modname, ext = os.path.splitext(os.path.basename(fname))
    full_mod = modname_of_file_name(fname)
    #raw_input(cp_names)
    prefix = (r'''

Local Ltac combine_pkgs CurveParameters_pkg ArithmeticSynthesisBase_pkg :=
  let CurveParameters_pkg := (eval hnf in CurveParameters_pkg) in
  let ArithmeticSynthesisBase_pkg := (eval hnf in ArithmeticSynthesisBase_pkg) in
  constr:((CurveParameters_pkg, ArithmeticSynthesisBase_pkg)).
''' % locals())
    for name, args in fns[fname]:
        if name[-1] != "'": raw_input(name)
        args = args.split(' ')
        prefix += ((r'''
Ltac pose_%s CurveParameters_pkg ArithmeticSynthesisBase_pkg %s :=
  let pkg := combine_pkgs CurveParameters_pkg ArithmeticSynthesisBase_pkg in
  lazymatch pkg with
  | ((%s), (%s))
'''
                 % (name[:-1],
                    ' '.join(arg for arg in args if arg.startswith('P_') or arg.endswith('_sig') or arg == name[:-1]),
                    ', '.join('?%s' % i for i in cp_names),
                    ', '.join('?%s' % i for i in base_names))).replace('  :=', ' :='))
        prefix += (r'''    => pose_%s %s
  end.
''' % (name, ' '.join(args)))
    pkg = make_package(fname, extra_modname_prefix='ArithmeticSynthesis', prefix=prefix, add_package=False)
    print(fname)
    pkg = unicode(pkg)
    write_package(fname, pkg)

def fix_reif_types():
    orig = contents['../ReificationTypes.v']
    new_val = (r'''  let pkg := combine_pkgs CurveParameters_pkg ArithmeticSynthesisBase_pkg in
  lazymatch pkg with
  | ((%s), (%s))'''
               % (', '.join('?%s' % i for i in cp_names),
                  ', '.join('?%s' % i for i in base_names)))
    find = re.compile(r'''  let pkg := combine_pkgs CurveParameters_pkg ArithmeticSynthesisBase_pkg in
  lazymatch pkg with
  .*''', flags=re.MULTILINE)
    assert(len(find.findall(orig)) == 1)
    ret = unicode(find.sub(new_val, orig))
    print('../ReificationTypes.v')
    if ret != orig:
        with io.open('../ReificationTypes.v', 'w', newline='\n') as f:
            f.write(ret)

fix_reif_types()    
##
##    ret = r'''Require Import %s.
##
##Local Ltac combine_pkgs CurveParameters_pkg ArithmeticSynthesisBase_pkg :=
##  let CurveParameters_pkg := (eval hnf in CurveParameters_pkg) in
##  let ArithmeticSynthesisBase_pkg := (eval hnf in ArithmeticSynthesisBase_pkg) in
##  constr:((CurveParameters_pkg, ArithmeticSynthesisBase_pkg)).
##
##Ltac get_ArithmeticSynthesisBase_package CurveParameters_pkg :=
##  lazymatch (eval hnf in CurveParameters_pkg) with
##  | (%s)''' % ', '.join('?%s' % i for i in cp_names))
##
##    with open(fname[:-2] + 'Package.v', 'w') as f:
##
##print(r'''Ltac get_ArithmeticSynthesisBase_package CurveParameters_pkg :=
##  lazymatch (eval hnf in CurveParameters_pkg) with
##  | (%s)''' % ', '.join('?%s' % i for i in cp_names))
##print('    => %s'
##    % '\n       '.join('let %s := fresh "%s" in' % (name, name) for name, args in fns))
##print('       ' + '\n       '.join('let %s := pose_%s %s in' % (name, name, args) for name, args in fns))
##print('       constr:((%s))' % ', '.join(name for name, args in fns))
##print('  end.')
##print(r'''
##Ltac make_ArithmeticSynthesisBase_package CurveParameters_pkg :=
##  lazymatch goal with
##  | [ |- { T : _ & T } ] => eexists
##  | [ |- _ ] => idtac
##  end;
##  let pkg := get_ArithmeticSynthesisBase_package CurveParameters_pkg in
##  exact pkg.
##
##Module Type ArithmeticSynthesisBasePrePackage.
##  Parameter ArithmeticSynthesisBase_package' : { T : _ & T }.
##  Parameter ArithmeticSynthesisBase_package : projT1 ArithmeticSynthesisBase_package'.
##End ArithmeticSynthesisBasePrePackage.
##
##Module MakeArithmeticSynthesisBaseTest (PKG : ArithmeticSynthesisBasePrePackage).
##  Ltac get_MakeArithmeticSynthesisBaseTest_package _ := eval hnf in PKG.ArithmeticSynthesisBase_package.
##  Ltac AS_reduce_proj x :=
##    eval cbv beta iota zeta in x.
##''')
##terms = ', '.join(name for name, args in fns)
##for name, args in fns:
##    print("  Ltac get_%s _ := let pkg := get_MakeArithmeticSynthesisBaseTest_package () in AS_reduce_proj (let '(%s) := pkg in %s)." % (name, terms, name))
##    print("  Notation %s := (ltac:(let v := get_%s () in exact v)) (only parsing)." % (name, name))
##print('End MakeArithmeticSynthesisBaseTest.')

add = λ var : Z.Syntax.base_type → Type,
λ '(x12, x13, x11, x9, x7, x5, x3, (x24, x25, x23, x21, x19, x17, x15))%core,
uint32_t x27, uint8_t x28 = addcarryx_u32(0x0, x3, x15);
uint32_t x30, uint8_t x31 = addcarryx_u32(x28, x5, x17);
uint32_t x33, uint8_t x34 = addcarryx_u32(x31, x7, x19);
uint32_t x36, uint8_t x37 = addcarryx_u32(x34, x9, x21);
uint32_t x39, uint8_t x40 = addcarryx_u32(x37, x11, x23);
uint32_t x42, uint8_t x43 = addcarryx_u32(x40, x13, x25);
uint32_t x45, uint8_t x46 = addcarryx_u32(x43, x12, x24);
uint32_t x48, uint8_t x49 = subborrow_u32(0x0, x27, 0xffffff8b);
uint32_t x51, uint8_t x52 = subborrow_u32(x49, x30, 0xffffffff);
uint32_t x54, uint8_t x55 = subborrow_u32(x52, x33, 0xffffffff);
uint32_t x57, uint8_t x58 = subborrow_u32(x55, x36, 0xffffffff);
uint32_t x60, uint8_t x61 = subborrow_u32(x58, x39, 0xffffffff);
uint32_t x63, uint8_t x64 = subborrow_u32(x61, x42, 0xffffffff);
uint32_t x66, uint8_t x67 = subborrow_u32(x64, x45, 0x3fffffff);
uint32_t _, uint8_t x70 = subborrow_u32(x67, x46, 0x0);
(cmovznz32(x70, x66, x45), cmovznz32(x70, x63, x42), cmovznz32(x70, x60, x39), cmovznz32(x70, x57, x36), cmovznz32(x70, x54, x33), cmovznz32(x70, x51, x30), cmovznz32(x70, x48, x27))
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t) -> uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t)

Argument scope is [function_scope]

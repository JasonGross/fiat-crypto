sub = λ var : Z.Syntax.base_type → Type,
λ '(x10, x11, x9, x7, x5, x3, (x20, x21, x19, x17, x15, x13))%core,
uint32_t x23, uint8_t x24 = subborrow_u32(0x0, x3, x13);
uint32_t x26, uint8_t x27 = subborrow_u32(x24, x5, x15);
uint32_t x29, uint8_t x30 = subborrow_u32(x27, x7, x17);
uint32_t x32, uint8_t x33 = subborrow_u32(x30, x9, x19);
uint32_t x35, uint8_t x36 = subborrow_u32(x33, x11, x21);
uint32_t x38, uint8_t x39 = subborrow_u32(x36, x10, x20);
uint32_t x40 = cmovznz32(x39, 0x0, 0xffffffff);
uint32_t x42, uint8_t x43 = addcarryx_u32(0x0, x23, (x40 & 0xfffffff5));
uint32_t x45, uint8_t x46 = addcarryx_u32(x43, x26, (x40 & 0xffffffff));
uint32_t x48, uint8_t x49 = addcarryx_u32(x46, x29, (x40 & 0xffffffff));
uint32_t x51, uint8_t x52 = addcarryx_u32(x49, x32, (x40 & 0xffffffff));
uint32_t x54, uint8_t x55 = addcarryx_u32(x52, x35, (x40 & 0xffffffff));
uint32_t x57, uint8_t _ = addcarryx_u32(x55, x38, (x40 & 0x3fffffff));
(Return x57, Return x54, Return x51, Return x48, Return x45, Return x42)
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * (uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t) -> uint32_t * uint32_t * uint32_t * uint32_t * uint32_t * uint32_t)

Argument scope is [function_scope]

square = λ var : Z.Syntax.base_type → Type,
λ '(x2, x3, x1)%core,
uint128_t x4 = ((uint128_t)x2 * x2);
uint128_t x5 = (((uint128_t)x3 * x2) + ((uint128_t)x2 * x3));
uint128_t x6 = (((uint128_t)x1 * x2) + (((uint128_t)x3 * x3) + ((uint128_t)x2 * x1)));
uint128_t x7 = (((uint128_t)x1 * x3) + ((uint128_t)x3 * x1));
uint128_t x8 = ((uint128_t)x1 * x1);
uint128_t x9 = (x7 + (0x11 * x4));
uint128_t x10 = (x8 + (0x11 * x5));
uint128_t x11 = (x10 >> 0x3a);
uint64_t x12 = ((uint64_t)x10 & 0x3ffffffffffffff);
uint128_t x13 = (x11 + x9);
uint128_t x14 = (x13 >> 0x3a);
uint64_t x15 = ((uint64_t)x13 & 0x3ffffffffffffff);
uint128_t x16 = (x14 + x6);
uint64_t x17 = (uint64_t) (x16 >> 0x3a);
uint64_t x18 = ((uint64_t)x16 & 0x3ffffffffffffff);
uint128_t x19 = (x12 + ((uint128_t)0x11 * x17));
uint64_t x20 = (uint64_t) (x19 >> 0x3a);
uint64_t x21 = ((uint64_t)x19 & 0x3ffffffffffffff);
uint64_t x22 = (x20 + x15);
uint64_t x23 = (x22 >> 0x3a);
uint64_t x24 = (x22 & 0x3ffffffffffffff);
return ((x23 + x18), Return x24, Return x21)
     : ∀ var : Z.Syntax.base_type → Type, expr Z.Syntax.base_type Z.Syntax.op (uint64_t * uint64_t * uint64_t -> uint64_t * uint64_t * uint64_t)

Argument scope is [function_scope]
